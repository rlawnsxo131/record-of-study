---
title: 4장_표현식과_연산자
description: 표현식과 연산자에 관해 설명한다. 대부분 생략하는데 eval 은 쓸데는 없을것 같지만 재미있다.
date: 2022-11-19
---

# 4장 표현식과 연산자

```
거의다 생략
```

- 쓸일은 거의 없겠지만서도 이런게 된단말이지.

```javascript
[1, , , , 3]; // [1, empty × 3, 3]
[1 + 1, 1 + 2]; // [2, 3]
```

- `in` 이나 `instanceof`

## 12. 평가 표현식(eval)

- 내가 사용할 일은 없을것 같아서 사용 방법보다는 사용시 문제, 주의점, 메커니즘을 위주로 기록한다.
- 인터프리터 언어가 대부분 그렇지만, 문자열을 JS 코드로 해석하고 평가해서 값을 얻을 수 있다.
- JS 에서는 전역함수 `eval()` 이 그 역할을 담당한다.
- 지나치게 강력한 기능이기도 하고 거의 필요로 하지 않는다.

- 추가로 `보안상 위험`한 부분이 있는데(내가 이걸 언제 봤는지 기억은 잘 안난다)
  - JS 처럼 복잡한 언어는 사용자 입력을 **eval()** 에 전달해도 안전할지 검사하는건 불가능하다.
  - 일부 웹 서버는 `Content-Security-Policy(CSP)` HTTP 헤더를 통해 eval()을 비활성화 한다.

```
Content-Security-Policy: script-src 'self' https://devlog.juntae.kim/
```

- _함수_ 이지만 사실 `연산자`로 보는것이 맞다는 내용이 있다.

  - JS 초기에는 함수로 정의했지만, 이후 언어설계자와 인터프리터 제작자들이 계속해서 제한을 가해 연산자에 가깝게 만들었다.

- `성능상의 문제`도 있다.
  - 현대의 자바스크립트 인터프리터는 코드 분석과 최적화를 아주 많이 수행한다.
  - 코드를 기계코드로 변환하는데 이때 변수명의 개념이 사실상 사라진다.
  - 허나 eval() 은 이게 불가능하다.
  - 브라우저는 기계코드에 해당 변수가 있는지 찾기위해 길고 무거운 변수명을 검색해야 한다.
  - eval()로 인해 자료형 변경등의 변화가 일어날 수 있으므로, 이에 대응하기 위한 기계코드를 재작성 해야한다.

### 12.1 eval()

- 인자 하나를 받는데 그 값이 문자열이 아니라면 그 값을 반환한다.
- 문자열을 전달하면 그 문자열을 JS 코드로 분석할 수 있는지 시도하고 실패시 Syntax Error 를 뱉는다.
- 분석 성공시 그 코드를 평가하고 해당 문자열의 `마지막 표현식/문의 값`을 반환하며, 마지막 표현식이나 문에 값이 없다면 undefined 를 반환한다.
- 이런 형태로 `eval()` 을 호출했을 때의 핵심은 자신을 호출한 코드의 변수의 환경을 사용한다는 것이다.
- 즉 로컬코드와 같은 방법으로 변수의 값을 검색하고 새로운 변수와 함수를 정의한다.

```javascript
function john() {
  let x = 1;
  eval("x = 2; console.log(x)");
}

john(); // 2
```

### 12.2 전역 eval()

- `eval()` 은 로컬 변수를 엉망으로 만들어서, JS 최적화를 하기가 곤란하게 만든다.
- 따라서 인터프리터는 **eval()** 을 호출하는 함수에 대해서는 적극적인 최적화를 하지 않는다.
- 하지만 스크립트에서 **eval()** 에대한 `별칭을 정의`하고 그 함수를 다른 이름으로 호출한다면 JS 는 어떻게 할까?

  - **'eval'** 이 아닌 이름으로 호출시 해당 문자열이 `최상위 전역 코드`인것 처럼 평가해야 한다고 정의한다.
  - 평가된 코드에서 전역 변수/함수를 새로 정의 가능하고, 전역 변수의 값을 바꿀 수도 있지만, 호출하는 함수의 로컬 변수는 아무것도 사용하거나 바꿀 수 없으므로 로컬 최적화를 방해할 수 없게된다.

- `직접호출`은 'eval' 이라는 이름을 그대로 사용하는 표현식으로 호출하는 것이다.

  - **eval()**을 직접호출 하면 호출하는 컨텍스트의 변수 환경을 사용한다.

- `간접호출`(직접 호출이 아닌 어떤 형태)로 호출하면 로컬 변수나 함수를 읽고, 쓰고, 정의하는 것이 불가능하다.

- `직접 호출`과 `간접 호출` 모두 `var` 를 통해서만 새 변수를 정의할 수있다.
  - 평가된 문자열 안에서 `let` 이나 `const` 를 사용하면 해당 평가에 종속되는 변수와 상수를 생성할 뿐, 호출 환경이나 전역 환경에 영향을 끼치지 않는다.

```javascript
const gEval = eval;
let x = "global";
let y = "global";

function f() {
  let x = "local";
  eval('x += "changed";');
  return x;
}

function g() {
  let y = "local";
  gEval('y += "changed";');
  return y;
}

console.log(f(), x); // localchanged global -> 로컬 변수 변경
console.log(g(), y); // local globalchanged -> 전역 변수 변경
```

### 12.3 스트릭트 eval()

- `스트릭트 모드`는 **eval()** 함수를 더 제한하고, **'eval'** 이라는 식별자 사용 역시 제한한다.
- 스트릭트 모드 코드에서 eval() 을 호출하거나 코드 문자열 자체가 **"use strict"** 지시자로 시작하는 것으로 평가되면 해당 eval() 은 `비공개 변수 환경`에서 `로컬`로 동작한다.
- 스트릭트 모드는 **'eval'**을 예약어처럼 만들어서 eval() 을 더 `연산자`에 가깝게 바꾼다.
- 스트릭트 모드에서는 eval() 함수를 새 값으로 덮어 쓸 수없다.
- 'eval' 이란 이름으로 변수나 함수, 함수 매개변수를 선언할 수 없고 블록을 캐치 할 수없다.

## 13. 기타 연산자

- `delete` 가 프로퍼티를 삭제하면, 존재하지 않는 프로퍼티가 된다.
  - 하지만 배열요소를 삭제하면 그 자리에 '구멍'이 생기지만 배열의 길이가 달라지지 않는다.
  - 배열쓸때 실수하지 않게 기억해두면 될듯하다.
- `void` 는 재밌긴 한데, 뭐 쓸일이 그닥?

```javascript
/**
 * delete
 */
const obj = {
  x: 1,
  y: 2,
};
delete obj.x;
"x" in obj; // false

const arr = [1, 2, 3];
delete arr[2];
2 in arr; // false -> [1, 2, undefined]
arr.length; // 3

/**
 * void
 */
let counter = 0;
const increment = () => void counter++;
increment(); // undefined
console.log(counter); // 1
```

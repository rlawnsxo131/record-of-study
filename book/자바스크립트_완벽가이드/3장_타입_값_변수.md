---
title: 3장_타입_값_변수
description: 타입,값,변수에 관해 설명한다.
date: 2022-11-19
---

# 3장 타입, 값, 변수

```
타입, 값, 변수에 관해 설명한다.
number 와 string 을 가장 자세히 설명하는 장.
후에 자세히 나오는 타입에 관한 내용은 생략하여 정리한다.

생략
2.1 문자열 리터럴
2.2 문자열 리터럴 안의 이스케이프 시퀀스
2.3 문자열 다루기
2.4 템플릿 리터럴
```

- JS 에서 `number`, `bool`, `symbol`, `null`, `undefined` 를 제외한 값은 모두 `객체` 이다.
- `symbol` 은 ES6 에서 추가되었는데, 하위 호환을 해치지 않으면서 언어의 확장을 정의하기 위해 추가 되었다.
- 일반적인 JS 의 객체는 이름붙은 `순서 없는 집합` 이다.
- `배열` 의 경우 특별한 객체인데, 순서가 있다는 점이 특별하다.

- `Set`, `Map`, `Typed Array` 객체는 11장에서 자세히 설명한다. 내가 첨언하자면

  - `Set` 은 값의 집합이고, `Map` 은 키와 값의 연결이다.
  - `Map` 의 경우 `object` 와 달리 순서가 보장되어 편리하게 사용한 경험이 꽤 있다.
  - `Set` 역시 중복을 허용하지 않기에 `new Set([...array])` 등의 형태로 편하게 사용했다.
  - `Typed Array` 의 경우 `Int8`, `UInt32`, `Float64` 등과 같은 값을 다루는데 사용되는데 일반적인 배열과는 `구분`이 확실히 가능하다. `Array.isArray()` 경우 역시 `false` 를 반환한다.
  - 참고로 `Typed Array` 의 경우 `Array Buffer`, `Blob` 데이터를 다룰 때 역시 사용한다.

- JS 의 `함수` 와 `클래스` 는 8,9장에서 자세히 설명한다.

  - 그저 문법의 일부분이라고는 볼 수 없는데, 다른 `정적언어` 와의 `차이점`이다.
  - `함수` 와 `클래스` 는 그 자체가 값이므로 프로그램에서 조작 가능하다.

- JS 는 오직 `객체`만이 `메서드`를 갖을 수 있다.
  - 하지만 `number`, `string`, `bool`, `Symbol` 도 마치 메서드가 있는 것처럼 동작한다.
  - 이 장에선 안나오지만 이는 `원시 래퍼객체(object wrapper)` 덕인데, 원시값에 접근하는 순간 특별한 객체가 만들어지고, 어떠한 작업(메서드 호출)이 끝나면 이 객체는 파괴된다.
  - 자바스크립트 엔진은 위 프로세스의 최적화에 많은 신경을 쓴다.
  - 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성(명세에 언급됨)한 것처럼 동작하게끔 해준다.
- JS 의 객체는 `가변(mutable)` 이며, 기본타입은 `불변(Immutable)` 이다.

## 1. 숫자(Number)

- 정수와 함께 `실수`를 `대략적`으로 표현한다.
- JS 는 `IEEE 754` 표준에서 정의하는 `64비트 부동 소수점` 형식을 사용한다.(java 에서 double)
  - 최대 **±1.7976931348623157** \* 10³⁰⁸, 최소 **±5 x 10⁻³²⁴** 범위의 숫자를 표현할 수 있다.
  - **-9007199254740991(-2⁵³)** 이상, **9007199254740991(2⁵³)** 이하의 `정수`를 **정확히** 표현 가능하다. 이는 `Number` 의 `MAX_SAFE_INTEGER`, `MIN_SAFE_INTEGER` 값의 범위이다.
  - 이보다 큰 정수를 정확히 표현하려면 ES2020 에서 추가된 `BigInt` 를 사용하면 되는데, 이는 `64bit 정수`범위를 표현하기 위해 만들어 졌다. 브라우저 호환 확인이 필요하다.

### 1.1 정수 리터럴

- JS 는 10진 정수 리터럴 뿐 아니라, 16진수 값도 인식한다.
- ES6 이후 버전에서는 `0b(2진수)`, `0o(8진수)` 를 앞에 붙여 정수로 표현할 수 있다.

```javascript
// 16 진수
console.log(0xff); // 255: (15*16 + 15)

// 2진수
console.log(0b10101); // 21: (1*16 + 0*8 + 1*4 + 0*2 + 1*1)

// 8진수
console.log(0o377); // 355: (3*64 + 7*8 + 7*1)
```

### 1.2 부동소수점 리터럴

- 일반적인 표기법으로 사용하는 것도 가능하고, 지수 표기법으로도 사용 가능하다.

```
3.14
2345.6789
.3333333333333333
6.02e23 // 6.02e+23: 6.02 * 10²³
1.4738223E-32 // 1.4738223e-32: 1.4738223 * 10⁻³²
```

### 1.3 자바스크립트의 산술 연산

- 여러 메서드를 설명하는데 다른 메서드 건너뛰고, 이 부분이 흥미롭다.

```javascript
/**
 *
 * imul 에 일반적인 자바스크립트 부동 소수점 숫자를 사용하면 성능이 떨어진다.
 * 성능이 떨어지는 주된 이유는 곱셈을 위해 부동 소숫점 숫자를 정수로 변환하고, 결과를 다시 부동 소수점
 * 숫자로 변환하는 비용 때문이다.
 * imul 이 존재하는 이유는(아직까지는), JIST 최적화기에서 자바스클비트 내부에서 정수를 좀 더 쉽게 구현할수
 * 있도록 돕는 AsmJS 단 하나때문이다.
 * 현재 브라우저에서 Math.imul 을 사용해 성능이 개선될 수 있는 부분은 내부적으로 정수로 저장된
 * (AsmJS 에서만 가능)숫자를 곱하는 경우뿐이다.
 */
Math.imul(2, 3); // 6: c 언어의 방식을 차용한 32 비트 정수의 곱셈
```

- JS 는 0으로 나누거나 `오버플로`, `언더플로`가 발생해도 에러를 일으키지 않는다.
- JS 가 표현 가능한 가장 큰 숫자보다 큰 경우(`오버플로`) `Infinity` 를 반환한다.
- `음수의 절댓값`이 JS 가 표현 가능한 가장 큰 숫자보다 큰 경우 `-Infinity` 를 반환한다.
- `언더플로`는 계산 결과가 자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0 에 가까울때 일어난다.
  - 음수에서 언더플로가 일어나면 `-0` 을 반환한다. 이값은 일반적인 0 과 **거의 완전히 같다.** 신경 X.
- JS 는 0 으로 나눠도 `+/- Infinity` 를 반환하고, 에러가 나지 않는다. 다만 예외가 있다.
  - 0 / 0 의 경우 정의되어 있지 않으므로 **NaN** 을 반환한다.
- JS 의 `Infinity` 와 `NaN` 은 `전역 상수`이며, `Number` 객체의 **프로퍼티**로도 존재한다.
- `NaN` 은 자기 자신을 포함해 어떤 값과도 같지 않다. `Number.isNaN(x)` 을 써서 비교해야 한다.

### 1.4 이진 부동 소수점 숫자와 반올림 오류

- JS 의 부동 소수점 형식으로 정확히 표현할 수 있는 숫자는 **유한**하다.
- 따라서 실수를 다룰때 실제 숫자의 **근삿값**으로 표현될 때가 자주 있다.
- `IEEE 754` 부동 소수점 표현은 이진 표현이며 1/2, 1/8, 1/1024 는 정확히 표현 가능하다.
  - 다만 1/10, 1/100 같이 단순한 숫자(`0.1`) 를 정확히 표현 불가능하다.
  - JS 숫자는 대단히 정밀한 편이며, 0.1 를 아주 가깝게 표현하지만 정확한것은 아니다.
  - 뭐 이건 다른 언어도 이런경우가 많아서, 내경우 실무에서 매출/정산 에 관련한 엔지니어링에 전반을 담당할 당시 사용하던 **Ruby** 에서도 삽질한적이 있다.

```javascript
/**
 * 워낙 유명한 현상이고, 설명도 많다.
 */
const sum = 0.1 + 0.2;
console.log(sum === 0.3); // false
console.log(sum); // 0.30000000000000004
```

### 1.5 BigInt 로 임의 정확도를 부여한 정수

- ES2020 에서 추가(예전엔 다 지원하지 않긴 했는데, 지금은 모르니 쓸일이 있으면 환경을 확인해보자).
- `64bit 정수`를 표현하기 위해 추가되었다.
- 참고로 `BigInt`는 타이밍 공격을 방지할 수 없으므로 `암호화`에서는 사용 불가능하다.
  - 타이밍 공격은 부채널 공격중 하나로 알고있고, 이건 소요시간을 분석해서 공격하는 방법으로 알고 있는데, 이를 방지할 수 없다는 이야기는 소요시간이 있는 그대로 드러나 측정을 가능케 한다는 이야기 같다.

```
// 예를들면 이런?
공격자는 101n ** 65537n 과 17n ** 9999n 사이의 시간 차이를 측정하고
경과된 시간을 기반으로 개인 키와 같은 비밀의 크기를 추론할 수 있다.
```

- 그래도 사용해야 한다면 아래 링크 참조해보자.

  - [https://timing.attacks.cr.yp.to/programming.html](https://timing.attacks.cr.yp.to/programming.html)

- `BigInt` 의 산술연산은 일반적인 산술 연산과 비슷하지만, 나눗셈을 할 때 나머지를 버린다는 점이 다르다.
  - 내 생각엔 이건 당연한 결과 같은데, 이름부터 **int** 가 들어가기 떄문.
  - 하나더 당연다 생각되는 부분은 BigInt 의 피연산자와 일반적인 숫자 피연산자를 `섞어 쓸 수 없다`는 부분이다.
  - 범위가 클지언정 이건 int 라는 부분에 매여있어 정수표현 외엔 제약을 갖는데, 이는 당연히 표현의 범위가 무조건 `Number` 보다 줄어드는 결과를 초래하는 것 아닌가 라는 생각이다.

```
1000n + 2000n // 3000n
3000n - 2000n // 1000n
3000n / 997n // 3n: 몫은 3
3000n % 997n // 9n: 나머지는 9
```

## 2. 텍스트(String)

- `16비트 값`이 순서에 따라 이어진 형태이며, 기본 값이므로 **불변**이다.
- 유니코드 문자셋의 UTF-16 인코딩을 사용하며, **부호없는 16bit 값의 연속**이다.
- 각 값은 일반적으로 유니코드 문자이다.
- 문자열의 길이는 그 문자열에 포함된 16비트 값의 개수이다.
- 문자 하나를 나타내는 타입은 없으며, 그냥 길이가 1인 문자열을 쓰면 16 비트 값이 된다.
- `emogi` 작업을 할때 만날 수 있는 `이모지 합성`과 `써로게이트 페어`관련 내용도 알아두면 좋을듯 하다.
  - 약간의 첨언을 하자면,
  - 이게 실무에서 이모지가 포함된 문자의 길이를 제한할때 굉장히 애매한 케이스가 있는데,
  - `db` 에 저장을 해야할 때 `varchar(200)` 등의 컬럼에 넣을때 이론적으로 이모지는 무한 합성이 가능하다.
  - 거기다 서로게이트 페어등으로 글자 길이가 확장이 되면 이게 그 숫자를 제한하기가 정말 굉장히 애매하다.
  - 그래서 어느정도는 용인하고 넘어갔던 케이스가 있음.

```javascript
/**
 * 코드 포인트가 16비트를 넘는 유니코드 문자는 16비트 값 두 개를 연속으로 쓰는
 * UTF-16 규칙(써로게이트 페어 - surro gate pair)으로 인코드 한다.
 * 즉, 길이가 2인(16비트 값이 두개인) 자바스크립트 문자열이 유니코드 문자 하나를 나타낸다.
 */
const euro = "€";
const love = "💙";
console.log(euro.length); // 1: 16bit 요소 하나
console.log(love.length); // 2: \ud83d\udc99
```

- JS 문자열 메서드는 대부분 문자가 아니라 16비트 값 단위로 동작한다.
- 서로게이트 페어를 특별히 취급하지 않는다.
- 따로 정규화 하지도 않고, 심지어 문자열이 정말 UTF-16 형식인지 검사하지도 않는다.
- 하지만 ES6 에서 문자열은 이터러블이고, 문자열에 `for/of` 루프나 `...` 연산자를 사용하면 16비트가 아닌 실제 문자를 순회한다.

### 2.1 문자열 리터럴

- 생략

### 2.2 문자열 리터럴 안의 이스케이프 시퀀스

- 생략

### 2.3 문자열 다루기

- 생략

### 2.4 템플릿 리터럴

- 생략

### 2.5 패턴 매칭(Regex)

- 생략

## 3. 불(Bool) 값

- falsy 를 제외한 나머지
- falsy
  - undefiend
  - null
  - 0
  - -0
  - NaN
  - ""

## 4. null과 undefined

- `null` 에 `typeof` 연산자 사용시 `object` 를 반환하는데, 이로 미루어 객체가 없다는 것을 나타내는 특별한 객체 값이라고 볼 수 있다.

- `undefined`의 경우는 초기화되지 않은 변수의 값이나 존재하지 않는 객체나 배열 요소에 접근시 반환되는 값이다.

- 두 값 모두 프로퍼티나 메서드가 없다.

- 점이나 대괄호를 써서 이들의 값에 접근하려 들면 `TypeError`가 발생.

```javascript
console.log(null == undefined); // true
console.log(null === undefined); // false
```

## 5. 심벌(Symbol)
